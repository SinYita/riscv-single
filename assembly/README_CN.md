# RISC-V 单周期 CPU 测试程序详细说明

## 程序概述

这个汇编程序全面测试了我们实现的RISC-V单周期CPU的所有指令类型。程序设计为逐步验证每种指令类型的功能，确保CPU能够正确执行所有已实现的操作。

## 指令类型详细分析

### 第一部分：立即数指令 (I-Type Instructions)

**功能描述：** I型指令使用12位立即数与寄存器进行运算

#### 1. 立即数加载指令
```assembly
addi x1, x0, 10        # x1 = 0 + 10 = 10
addi x2, x0, 20        # x2 = 0 + 20 = 20  
addi x3, x0, -5        # x3 = 0 + (-5) = -5
```
- **用途：** 初始化寄存器值，因为RISC-V没有直接的立即数加载指令
- **原理：** 利用x0寄存器恒为0的特性，通过加法实现立即数加载
- **测试重点：** 正数、负数的立即数处理和符号扩展

#### 2. 逻辑立即数操作
```assembly
xori x4, x1, 15        # x4 = 10 XOR 15 = 5
ori  x5, x2, 7         # x5 = 20 OR 7 = 23
andi x6, x1, 14        # x6 = 10 AND 14 = 10
```
- **用途：** 位操作，常用于掩码操作和位域提取
- **计算详解：**
  - XOR: 1010 XOR 1111 = 0101 (十进制5)
  - OR:  10100 OR 111 = 10111 (十进制23)
  - AND: 1010 AND 1110 = 1010 (十进制10)

#### 3. 移位立即数操作
```assembly
slli x7, x1, 2         # x7 = 10 << 2 = 40
srli x8, x7, 1         # x8 = 40 >> 1 = 20
srai x9, x3, 1         # x9 = -5 >>> 1 = -3
```
- **SLLI (左移)：** 每左移1位相当于乘以2
- **SRLI (逻辑右移)：** 高位补0，无符号右移
- **SRAI (算术右移)：** 高位补符号位，保持数值符号

#### 4. 比较立即数操作
```assembly
slti  x10, x1, 15      # x10 = (10 < 15) ? 1 : 0 = 1
sltiu x11, x3, 10      # x11 = (0xFFFFFFFB < 10) ? 1 : 0 = 0
```
- **SLTI：** 有符号比较，-5 < 15，结果为1
- **SLTIU：** 无符号比较，0xFFFFFFFB（-5的无符号表示）> 10，结果为0

### 第二部分：寄存器指令 (R-Type Instructions)

**功能描述：** R型指令在两个寄存器之间进行运算

#### 1. 算术运算
```assembly
add  x12, x1, x2       # x12 = 10 + 20 = 30
sub  x13, x2, x1       # x13 = 20 - 10 = 10
```
- **测试目的：** 验证ALU的加减法功能
- **关键点：** 溢出处理和进位标志

#### 2. 逻辑运算
```assembly
xor  x14, x1, x2       # x14 = 10 XOR 20 = 30
or   x15, x4, x5       # x15 = 5 OR 23 = 23  
and  x16, x1, x6       # x16 = 10 AND 10 = 10
```
- **测试覆盖：** 全部位操作指令
- **应用场景：** 位掩码、位清零/置位操作

#### 3. 移位运算
```assembly
sll  x17, x1, x2       # x17 = 10 << (20 & 0x1F) = 10 << 20
srl  x18, x12, x1      # x18 = 30 >> (10 & 0x1F) = 0
sra  x19, x3, x1       # x19 = -5 >>> 10 = -1
```
- **重要特性：** 移位量取低5位，最大移位31位
- **区别：** SRL逻辑右移 vs SRA算术右移

### 第三部分：上位立即数指令 (U-Type Instructions)

```assembly
lui  x22, 0x12345      # x22 = 0x12345000
```
- **功能：** 加载20位立即数到寄存器的高20位，低12位清零
- **用途：** 构造32位常数的高位部分
- **配合使用：** 通常与ADDI配合构造完整的32位常数

### 第四部分：内存访问指令 (Load/Store Instructions)

#### 存储指令
```assembly
sw   x24, 0(x23)       # 将x24存储到内存[x23+0]
sw   x12, 4(x23)       # 将x12存储到内存[x23+4]
```

#### 加载指令  
```assembly
lw   x25, 0(x23)       # 从内存[x23+0]加载到x25
lw   x26, 4(x23)       # 从内存[x23+4]加载到x26
```
- **地址计算：** 基址寄存器 + 12位有符号偏移量
- **内存对齐：** 字(4字节)必须4字节对齐
- **测试验证：** 存储后立即加载，验证数据完整性

### 第五部分：分支指令 (Branch Instructions)

#### 条件分支
```assembly
beq  x28, x29, equal_branch    # 相等则跳转
```
- **条件判断：** 比较两个寄存器是否相等
- **跳转地址：** PC + 符号扩展的12位偏移量
- **测试场景：**
  - 条件为真：跳转到目标地址
  - 条件为假：继续执行下一条指令

#### 分支测试逻辑
1. **相等分支：** x28 = x29 = 10，应该跳转
2. **不等分支：** x28 = 10, x29 = 5，不应跳转

### 第六部分：跳转指令 (Jump Instructions)

```assembly
jal  x1, function_call # 跳转并链接
```
- **功能：** 无条件跳转到目标地址
- **链接：** 将PC+4存储到目标寄存器(返回地址)
- **用途：** 函数调用和长距离跳转

## 程序执行流程

1. **初始化阶段：** 设置基本的寄存器值
2. **算术逻辑测试：** 验证ALU各种运算功能
3. **内存操作测试：** 验证Load/Store单元
4. **控制流测试：** 验证分支和跳转逻辑
5. **结束循环：** 程序以无限循环结束

## 验证要点

### CPU功能验证
- **数据通路：** 所有数据在各个模块间正确传递
- **控制单元：** 正确生成各种控制信号
- **ALU功能：** 所有算术和逻辑运算正确
- **内存接口：** 读写操作正确执行
- **PC控制：** 顺序执行和跳转正确

### 预期结果
执行完成后，各寄存器应包含：
- x1 = 返回地址 (JAL指令设置)
- x2 = 300 (从函数返回后设置)
- x3 = 400 (函数中设置) 
- x10 = 1 (比较结果)
- x25-x27 = 从内存加载的数据
- x30 = 100 (分支成功标志)
- x31 = 200 (分支失败标志)

## 使用方法

1. **编译：** 使用RISC-V汇编器将.s文件编译为机器码
2. **转换：** 将机器码转换为CPU可读的hex格式
3. **加载：** 将hex文件加载到instruction memory
4. **仿真：** 运行CPU仿真，观察寄存器和内存变化
5. **验证：** 检查最终结果是否符合预期

这个测试程序全面覆盖了单周期CPU的所有功能模块，是验证CPU设计正确性的理想测试用例。