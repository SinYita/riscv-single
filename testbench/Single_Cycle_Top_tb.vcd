$date
	Thu Dec  4 17:13:59 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module Single_Cycle_Top_tb $end
$var wire 32 ! reg_write_data [31:0] $end
$var wire 32 " reg_data2 [31:0] $end
$var wire 32 # reg_data1 [31:0] $end
$var wire 32 $ memory_read_data [31:0] $end
$var wire 32 % instruction [31:0] $end
$var wire 32 & immediate [31:0] $end
$var wire 1 ' Zero $end
$var wire 1 ( ResultSrc $end
$var wire 1 ) RegWrite $end
$var wire 32 * PC_next [31:0] $end
$var wire 32 + PC_current [31:0] $end
$var wire 1 , PCSrc $end
$var wire 1 - MemWrite $end
$var wire 3 . ImmSrc [2:0] $end
$var wire 32 / ALU_srcB [31:0] $end
$var wire 32 0 ALU_result [31:0] $end
$var wire 1 1 ALUSrc $end
$var wire 4 2 ALUControl [3:0] $end
$var reg 1 3 clk $end
$var reg 32 4 instr_cycle1 [31:0] $end
$var reg 32 5 instr_cycle2 [31:0] $end
$var reg 32 6 pc_cycle1 [31:0] $end
$var reg 32 7 pc_cycle2 [31:0] $end
$var reg 1 8 rst $end
$var reg 1 9 test_passed $end
$var integer 32 : cycle_count [31:0] $end
$var integer 32 ; test_count [31:0] $end
$scope module alu_inst $end
$var wire 1 ' Zero $end
$var wire 32 < B [31:0] $end
$var wire 4 = ALUControl [3:0] $end
$var wire 32 > A [31:0] $end
$var reg 32 ? Result [31:0] $end
$upscope $end
$scope module alu_srcb_mux $end
$var wire 1 1 sel $end
$var wire 32 @ out [31:0] $end
$var wire 32 A in_2 [31:0] $end
$var wire 32 B in_1 [31:0] $end
$upscope $end
$scope module ctrl_inst $end
$var wire 1 ' Zero $end
$var wire 3 C funct3 [2:0] $end
$var wire 7 D funct7 [6:0] $end
$var wire 32 E inst [31:0] $end
$var wire 1 ( ResultSrc $end
$var wire 1 ) RegWrite_E $end
$var wire 1 , PCSrc $end
$var wire 7 F Op [6:0] $end
$var wire 1 - MemWrite_E $end
$var wire 3 G ImmSrc [2:0] $end
$var wire 1 1 ALUSrc $end
$var wire 3 H ALUOp [2:0] $end
$var wire 4 I ALUControl [3:0] $end
$scope module alu_decoder $end
$var wire 3 J funct3 [2:0] $end
$var wire 7 K funct7 [6:0] $end
$var wire 7 L op [6:0] $end
$var wire 3 M ALUOp [2:0] $end
$var reg 4 N ALUControl [3:0] $end
$upscope $end
$scope module main_decoder $end
$var wire 1 ' Zero $end
$var wire 32 O inst [31:0] $end
$var wire 7 P Op [6:0] $end
$var wire 7 Q Funct7 [6:0] $end
$var wire 3 R Funct3 [2:0] $end
$var reg 3 S ALUOp [2:0] $end
$var reg 1 1 ALUSrc $end
$var reg 3 T ImmSrc [2:0] $end
$var reg 1 - MemWrite_E $end
$var reg 1 , PCSrc $end
$var reg 1 ) RegWrite_E $end
$var reg 1 ( ResultSrc $end
$upscope $end
$upscope $end
$scope module dmem_inst $end
$var wire 32 U A [31:0] $end
$var wire 1 - WE $end
$var wire 1 3 clk $end
$var wire 1 8 rst $end
$var wire 32 V WD [31:0] $end
$var wire 32 W RD [31:0] $end
$upscope $end
$scope module imem_inst $end
$var wire 1 8 rst $end
$var wire 32 X ReadData [31:0] $end
$var wire 32 Y Address [31:0] $end
$upscope $end
$scope module npc_inst $end
$var wire 1 , PCSrc $end
$var wire 32 Z PCPLUS4 [31:0] $end
$var wire 32 [ PC [31:0] $end
$var wire 32 \ IMMEXT [31:0] $end
$var reg 32 ] NPC [31:0] $end
$upscope $end
$scope module pc_inst $end
$var wire 32 ^ NPC [31:0] $end
$var wire 1 3 clk $end
$var wire 1 8 rst $end
$var reg 32 _ PC [31:0] $end
$upscope $end
$scope module result_mux $end
$var wire 32 ` in_1 [31:0] $end
$var wire 32 a in_2 [31:0] $end
$var wire 1 ( sel $end
$var wire 32 b out [31:0] $end
$upscope $end
$scope module rf_inst $end
$var wire 5 c Address1 [4:0] $end
$var wire 5 d Address2 [4:0] $end
$var wire 5 e Address3 [4:0] $end
$var wire 32 f RD1 [31:0] $end
$var wire 32 g RD2 [31:0] $end
$var wire 32 h WD3 [31:0] $end
$var wire 1 ) WriteEnable3 $end
$var wire 1 3 clk $end
$var wire 1 8 rst $end
$var integer 32 i i [31:0] $end
$upscope $end
$scope module sext_inst $end
$var wire 3 j Imm_src [2:0] $end
$var wire 32 k Ins [31:0] $end
$var reg 32 l ImmExt [31:0] $end
$upscope $end
$scope task check_memory $end
$var reg 32 m actual_value [31:0] $end
$var reg 32 n expected_value [31:0] $end
$var reg 32 o mem_addr [31:0] $end
$var reg 256 p test_name [255:0] $end
$upscope $end
$scope task check_register $end
$var reg 32 q actual_value [31:0] $end
$var reg 32 r expected_value [31:0] $end
$var reg 5 s reg_addr [4:0] $end
$var reg 256 t test_name [255:0] $end
$upscope $end
$scope task display_cpu_state $end
$var reg 256 u stage_name [255:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
bx m
b0 l
b0 k
b0 j
bx i
bx h
bx g
bx f
b0 e
b0 d
b0 c
bx b
b0 a
bx `
bx _
bx ^
bx ]
b0 \
bx [
bx Z
bx Y
b0 X
b0 W
bx V
bx U
b0 T
b10 S
b0 R
b0 Q
b0 P
b0 O
b100 N
b10 M
b0 L
b0 K
b0 J
b100 I
b10 H
b0 G
b0 F
b0 E
b0 D
b0 C
bx B
b0 A
bx @
bx ?
bx >
b100 =
bx <
b0 ;
b0 :
19
08
bx 7
bx 6
bx 5
bx 4
03
b100 2
01
bx 0
bx /
b0 .
0-
0,
bx +
bx *
0)
0(
x'
b0 &
b0 %
b0 $
bx #
bx "
bx !
$end
#5000
b0 !
b0 b
b0 h
1'
b0 0
b0 ?
b0 U
b0 `
b0 /
b0 <
b0 @
b100 *
b100 ]
b100 ^
b0 #
b0 >
b0 f
b0 "
b0 B
b0 V
b0 g
b100 Z
b0 +
b0 Y
b0 [
b0 _
b100000 i
13
#10000
03
b1 :
#15000
b100000 i
13
#20000
b1000 *
b1000 ]
b1000 ^
b1 H
b1 M
b1 S
1)
b110 &
b110 A
b110 \
b110 l
b1000 Z
b100 +
b100 Y
b100 [
b100 _
b111 2
b111 =
b111 I
b111 N
b111 R
b110011 P
b110011 F
b110011 L
b111 C
b111 J
b1000 e
b110 d
b101 c
bx $
bx W
bx a
b11000101111010000110011 %
b11000101111010000110011 E
b11000101111010000110011 O
b11000101111010000110011 X
b11000101111010000110011 k
03
b10 :
18
#25000
b10 H
b10 M
b10 S
0)
bx &
bx A
bx \
bx l
bx !
bx b
bx h
x'
bx 0
bx ?
bx U
bx `
b0 2
b0 =
b0 I
b0 N
bx /
bx <
bx @
bx Q
bx R
bx P
bx F
bx L
bx D
bx K
bx C
bx J
bx e
bx "
bx B
bx V
bx g
bx d
bx #
bx >
bx f
bx c
bx %
bx E
bx O
bx X
bx k
b1100 *
b1100 ]
b1100 ^
b1100 Z
b1000 +
b1000 Y
b1000 [
b1000 _
13
#30000
03
b11 :
b1001001011011100110100101110100011010010110000101101100001000000101001101110100011000010111010001100101001000000100000101100110011101000110010101110010001000000101001001100101011100110110010101110100 u
#35000
b10000 *
b10000 ]
b10000 ^
b10000 Z
b1100 +
b1100 Y
b1100 [
b1100 _
13
#36000
b10000110111100101100011011011000110010100100000010001010111100001100101011000110111010101110100011010010110111101101110 u
#40000
03
b100 :
#45000
b10100 *
b10100 ]
b10100 ^
b10100 Z
b10000 +
b10000 Y
b10000 [
b10000 _
13
#50000
03
b101 :
#55000
b11000 *
b11000 ]
b11000 ^
b11000 Z
b10100 +
b10100 Y
b10100 [
b10100 _
13
#60000
03
b110 :
#65000
b11100 *
b11100 ]
b11100 ^
b11100 Z
b11000 +
b11000 Y
b11000 [
b11000 _
13
#70000
03
b111 :
#75000
b100000 *
b100000 ]
b100000 ^
b100000 Z
b11100 +
b11100 Y
b11100 [
b11100 _
13
#80000
03
b1000 :
#85000
b100100 *
b100100 ]
b100100 ^
b0 &
b0 A
b0 \
b0 l
b100100 Z
b100000 +
b100000 Y
b100000 [
b100000 _
b0 !
b0 b
b0 h
b100 2
b100 =
b100 I
b100 N
b0 /
b0 <
b0 @
1'
b0 0
b0 ?
b0 U
b0 `
b0 Q
b0 R
b0 P
b0 F
b0 L
b0 D
b0 K
b0 C
b0 J
b0 e
b0 "
b0 B
b0 V
b0 g
b0 d
b0 #
b0 >
b0 f
b0 c
b0 $
b0 W
b0 a
b0 %
b0 E
b0 O
b0 X
b0 k
08
09
b11 ;
b10001100110100101101110011000010110110000100000010001010111100001100101011000110111010101110100011010010110111101101110001000000101001101110100011000010111010001100101 u
13
#90000
03
b1001 :
#95000
b100 *
b100 ]
b100 ^
b100 Z
b0 +
b0 Y
b0 [
b0 _
b100000 i
13
#100000
03
b1010 :
#105000
b1000 *
b1000 ]
b1000 ^
b1 H
b1 M
b1 S
1)
b110 &
b110 A
b110 \
b110 l
b1000 Z
b100 +
b100 Y
b100 [
b100 _
b111 2
b111 =
b111 I
b111 N
b111 R
b110011 P
b110011 F
b110011 L
b111 C
b111 J
b1000 e
b110 d
b101 c
bx $
bx W
bx a
b11000101111010000110011 %
b11000101111010000110011 E
b11000101111010000110011 O
b11000101111010000110011 X
b11000101111010000110011 k
13
18
b100 ;
#110000
03
b1011 :
#115000
b10 H
b10 M
b10 S
0)
bx &
bx A
bx \
bx l
bx !
bx b
bx h
x'
bx 0
bx ?
bx U
bx `
b0 2
b0 =
b0 I
b0 N
bx /
bx <
bx @
bx Q
bx R
bx P
bx F
bx L
bx D
bx K
bx C
bx J
bx e
bx "
bx B
bx V
bx g
bx d
bx #
bx >
bx f
bx c
bx %
bx E
bx O
bx X
bx k
b1100 *
b1100 ]
b1100 ^
b1100 Z
b1000 +
b1000 Y
b1000 [
b1000 _
13
#116000
b1000 6
#120000
03
b1100 :
#125000
b10000 *
b10000 ]
b10000 ^
b10000 Z
b1100 +
b1100 Y
b1100 [
b1100 _
13
#126000
b10001100110100101101110011000010110110000100000010000110101000001010101001000000101001101110100011000010111010001100101 u
b101 ;
b1100 7
#130000
03
b1101 :
#135000
b10100 *
b10100 ]
b10100 ^
b10100 Z
b10000 +
b10000 Y
b10000 [
b10000 _
13
#140000
03
b1110 :
#145000
b11000 *
b11000 ]
b11000 ^
b11000 Z
b10100 +
b10100 Y
b10100 [
b10100 _
13
#150000
03
b1111 :
#155000
b11100 *
b11100 ]
b11100 ^
b11100 Z
b11000 +
b11000 Y
b11000 [
b11000 _
13
#160000
03
b10000 :
#165000
b100000 *
b100000 ]
b100000 ^
b100000 Z
b11100 +
b11100 Y
b11100 [
b11100 _
13
#170000
03
b10001 :
#175000
b100100 *
b100100 ]
b100100 ^
b100100 Z
b100000 +
b100000 Y
b100000 [
b100000 _
13
#176000
