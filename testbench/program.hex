# RISC-V Assembly to Machine Code Conversion
# simple_test.s -> machine code

# Instruction Format Reference:
# R-type: funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
# I-type: imm[31:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
# S-type: imm[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:7] | opcode[6:0]
# B-type: imm[31] | imm[30:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:8] | imm[7] | opcode[6:0]
# U-type: imm[31:12] | rd[11:7] | opcode[6:0]
# J-type: imm[31] | imm[30:21] | imm[20] | imm[19:12] | rd[11:7] | opcode[6:0]

# Address 0x00: addi x1, x0, 10        # x1 = 10
# I-type: 000000001010 | 00000 | 000 | 00001 | 0010011
# Binary: 00000000101000000000000010010011
# Hex: 0x00A00093

# Address 0x04: addi x2, x0, 20        # x2 = 20  
# I-type: 000000010100 | 00000 | 000 | 00010 | 0010011
# Binary: 00000001010000000000000100010011
# Hex: 0x01400113

# Address 0x08: add x3, x1, x2         # x3 = x1 + x2 = 30
# R-type: 0000000 | 00010 | 00001 | 000 | 00011 | 0110011
# Binary: 00000000001000001000000110110011
# Hex: 0x002081B3

# Address 0x0C: sub x4, x2, x1         # x4 = x2 - x1 = 10
# R-type: 0100000 | 00001 | 00010 | 000 | 00100 | 0110011
# Binary: 01000000000100010000001000110011
# Hex: 0x40110233

# Address 0x10: xor x5, x1, x2         # x5 = x1 XOR x2
# R-type: 0000000 | 00010 | 00001 | 100 | 00101 | 0110011
# Binary: 00000000001000001100001010110011
# Hex: 0x0020C2B3

# Address 0x14: or x6, x1, x2          # x6 = x1 OR x2
# R-type: 0000000 | 00010 | 00001 | 110 | 00110 | 0110011  
# Binary: 00000000001000001110001100110011
# Hex: 0x0020E333

# Address 0x18: and x7, x1, x2         # x7 = x1 AND x2
# R-type: 0000000 | 00010 | 00001 | 111 | 00111 | 0110011
# Binary: 00000000001000001111001110110011
# Hex: 0x0020F3B3

# Address 0x1C: xori x8, x1, 15        # x8 = x1 XOR 15
# I-type: 000000001111 | 00001 | 100 | 01000 | 0010011
# Binary: 00000000111100001100010000010011
# Hex: 0x00F0C413

# Address 0x20: ori x9, x1, 7          # x9 = x1 OR 7
# I-type: 000000000111 | 00001 | 110 | 01001 | 0010011
# Binary: 00000000011100001110010010010011
# Hex: 0x0070E493

# Address 0x24: andi x10, x1, 14       # x10 = x1 AND 14
# I-type: 000000001110 | 00001 | 111 | 01010 | 0010011
# Binary: 00000000111000001111010100010011
# Hex: 0x00E0F513

# Address 0x28: slli x11, x1, 2        # x11 = x1 << 2
# I-type: 000000000010 | 00001 | 001 | 01011 | 0010011
# Binary: 00000000001000001001010110010011
# Hex: 0x00209593

# Address 0x2C: srli x12, x3, 1        # x12 = x3 >> 1
# I-type: 000000000001 | 00011 | 101 | 01100 | 0010011
# Binary: 00000000000100011101011000010011
# Hex: 0x0011D613

# Address 0x30: slt x13, x1, x2        # x13 = (x1 < x2) ? 1 : 0
# R-type: 0000000 | 00010 | 00001 | 010 | 01101 | 0110011
# Binary: 00000000001000001010011010110011
# Hex: 0x0020A6B3

# Address 0x34: sltu x14, x1, x2       # x14 = (x1 < x2 unsigned) ? 1 : 0
# R-type: 0000000 | 00010 | 00001 | 011 | 01110 | 0110011
# Binary: 00000000001000001011011100110011
# Hex: 0x0020B733

# Address 0x38: addi x15, x0, 100      # x15 = 内存地址
# I-type: 000001100100 | 00000 | 000 | 01111 | 0010011
# Binary: 00000110010000000000011110010011
# Hex: 0x06400793

# Address 0x3C: sw x3, 0(x15)          # 存储x3到内存
# S-type: 0000000 | 00011 | 01111 | 010 | 00000 | 0100011
# Binary: 00000000001101111010000000100011
# Hex: 0x003FA023

# Address 0x40: lw x16, 0(x15)         # 从内存加载到x16
# I-type: 000000000000 | 01111 | 010 | 10000 | 0000011
# Binary: 00000000000001111010100000000011
# Hex: 0x0007A803

# Address 0x44: lui x17, 0x1234        # x17 = 0x12340000
# U-type: 00000001001000110100 | 10001 | 0110111
# Binary: 00000001001000110100100010110111
# Hex: 0x012348B7

# Address 0x48: beq x1, x1, branch1    # x1 == x1，应该跳转 (offset = +8)
# B-type: offset[12] | offset[10:5] | 00001 | 00001 | 000 | offset[4:1] | offset[11] | 1100011
# offset = 8 = 0000000001000, offset[12]=0, offset[11]=0, offset[10:5]=000000, offset[4:1]=0100
# Binary: 00000000000100001000001001100011
# Hex: 0x00108463

# Address 0x4C: addi x18, x0, 999      # 不应执行
# I-type: 001111100111 | 00000 | 000 | 10010 | 0010011
# Binary: 00111110011100000000100100010011
# Hex: 0x3E700913

# Address 0x50: addi x18, x0, 100      # x18 = 100，标记跳转成功 (branch1:)
# I-type: 000001100100 | 00000 | 000 | 10010 | 0010011
# Binary: 00000110010000000000100100010011
# Hex: 0x06400913

# Address 0x54: beq x0, x0, end        # 无限循环 (offset = 0, jump to self)
# B-type: offset[12] | offset[10:5] | 00000 | 00000 | 000 | offset[4:1] | offset[11] | 1100011
# offset = 0 = 0000000000000
# Binary: 00000000000000000000000001100011
# Hex: 0x00000063

00A00093
01400113
002081B3
40110233
0020C2B3
0020E333
0020F3B3
00F0C413
0070E493
00E0F513
00209593
0011D613
0020A6B3
0020B733
06400793
003FA023
0007A803
012348B7
00108463
3E700913
06400913
00000063